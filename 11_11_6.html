<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ç«‹æ–¹ä½“ã®å±•é–‹å›³ - WebXRå¯¾å¿œç‰ˆ</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    #container {
      width: 100vw;
      height: 100vh;
    }
    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 100;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      transition: all 0.3s ease;
    }
    #controlsHeader {
      padding: 15px 20px;
      cursor: pointer;
      user-select: none;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #controlsHeader:hover {
      background: linear-gradient(135deg, #7c8eeb 0%, #8757ad 100%);
    }
    #controlsHeader h2 {
      margin: 0;
      font-size: 18px;
    }
    #toggleIcon {
      font-size: 20px;
      transition: transform 0.3s ease;
    }
    #toggleIcon.expanded { transform: rotate(180deg); }
    #controlsContent {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    #controlsContent.expanded { max-height: 600px; }
    #controlsInner { padding: 20px; }
    .pattern-section { margin-bottom: 20px; }
    .pattern-section h3 {
      margin: 10px 0 5px 0;
      color: #666;
      font-size: 14px;
    }
    .button-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }
    button {
      padding: 10px 16px;
      font-size: 14px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-weight: bold;
      transition: all 0.2s;
    }
    button:hover { transform: scale(1.05); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
    button:active { transform: scale(0.95); }
    button.active { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
    .control-buttons { display: flex; gap: 8px; margin-top: 15px; }
    .control-buttons button { flex: 1; }
    .slider-container { margin: 15px 0; }
    .slider-container label {
      display: block;
      margin-bottom: 5px;
      color: #666;
      font-weight: bold;
    }
    input[type="range"] { width: 100%; }
    #progressValue {
      display: inline-block;
      width: 40px;
      text-align: right;
      color: #667eea;
      font-weight: bold;
    }
    #info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
      max-width: 360px;
    }
    #currentPattern {
      font-weight: bold;
      color: #ffd93d;
      font-size: 16px;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <div id="controls">
    <div id="controlsHeader">
      <h2>ğŸ² ç«‹æ–¹ä½“ã®å±•é–‹å›³ï¼ˆWebXRå¯¾å¿œç‰ˆï¼‰</h2>
      <span id="toggleIcon">â–¼</span>
    </div>
    <div id="controlsContent">
      <div id="controlsInner">
        <div class="pattern-section">
          <h3>ğŸ“‹ å±•é–‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸æŠ</h3>
          <div class="button-grid">
            <button class="pattern-btn active" data-pattern="0">A. 1-4-1å‹A (åå­—å‹)</button>
            <button class="pattern-btn" data-pattern="1">B. 1-4-1å‹B (å¸¯å‹1)</button>
            <button class="pattern-btn" data-pattern="2">C. 1-4-1å‹C (Lå­—å‹)</button>
            <button class="pattern-btn" data-pattern="3">D. 1-4-1å‹D (Lå­—å¤‰å½¢1)</button>
            <button class="pattern-btn" data-pattern="4">E. 1-4-1å‹E (Tå­—å‹)</button>
            <button class="pattern-btn" data-pattern="5">F. 1-4-1å‹F (å¸¯å‹2)</button>
            <button class="pattern-btn" data-pattern="6">G. 1-3-2å‹G (ã‚¸ã‚°ã‚¶ã‚°å‹)</button>
            <button class="pattern-btn" data-pattern="7">H. 1-3-2å‹H (Wå­—å‹)</button>
            <button class="pattern-btn" data-pattern="8">I. 1-3-2å‹I (éšæ®µå‹)</button>
            <button class="pattern-btn" data-pattern="9">J. 3-3å‹J (ãƒ—ãƒ­ãƒšãƒ©å‹)</button>
            <button class="pattern-btn" data-pattern="10">K. 2-2-2å‹K (éšæ®µå‹2)</button>
          </div>
        </div>

        <div class="control-buttons">
          <button id="unfoldBtn">å±•é–‹</button>
          <button id="foldBtn">é–‰ã˜ã‚‹</button>
          <button id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
        </div>

        <div class="slider-container">
          <label>å±•é–‹åº¦: <span id="progressValue">0</span>%</label>
          <input type="range" id="progressSlider" min="0" max="100" value="0" />
        </div>
      </div>
    </div>
  </div>

  <div id="info">
    <div id="currentPattern">ç¾åœ¨: A. 1-4-1å‹A (åå­—å‹)</div>
    ğŸ’¡ ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°ã§å›è»¢ / ãƒ›ã‚¤ãƒ¼ãƒ«ã§æ‹¡å¤§ç¸®å°<br />
    ğŸ•¶ï¸ VRå¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ + ãƒ˜ãƒƒãƒ‰ã‚»ãƒƒãƒˆ: å³ä¸‹ or å·¦ä¸‹ã® <b>Enter VR</b> ãƒœã‚¿ãƒ³ã‹ã‚‰å…¥å®¤<br />
    ğŸ”— é¢ã¯æ­£ã—ã„å¯¾é¢é–¢ä¿‚ã§å±•é–‹
  </div>

  <!-- Three.js (r128) Non-module build for global THREE namespace -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // === UIãƒ‘ãƒãƒ«é–‹é–‰ ===
    const controlsHeader = document.getElementById('controlsHeader');
    const controlsContent = document.getElementById('controlsContent');
    const toggleIcon = document.getElementById('toggleIcon');
    let isExpanded = false;
    controlsHeader.addEventListener('click', () => {
      isExpanded = !isExpanded;
      controlsContent.classList.toggle('expanded', isExpanded);
      toggleIcon.classList.toggle('expanded', isExpanded);
    });

    // === Three.js ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    // === VRé–‹å§‹ä½ç½®ã‚’èª¿æ•´ã™ã‚‹ãŸã‚ã®è¦ªã‚°ãƒ«ãƒ¼ãƒ— ===
    const stage = new THREE.Group();
    scene.add(stage);

    // === VRç”¨UIï¼ˆ3Dãƒ‘ãƒãƒ«ï¼‰ ===
    const vrUIRoot = new THREE.Group();
    stage.add(vrUIRoot);

    const vrButtons = []; // 3Dãƒœã‚¿ãƒ³ã®Meshé…åˆ—
    let vrHovered = null;

    function makeCanvasLabel(text, w = 256, h = 64) {
      const canvas = document.createElement('canvas');
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#6b46c1';
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 28px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, w/2, h/2);
      return new THREE.CanvasTexture(canvas);
    }

    function makeVRButton(label, onClick) {
      const geo = new THREE.PlaneGeometry(0.6, 0.18);
      const mat = new THREE.MeshBasicMaterial({ map: makeCanvasLabel(label), transparent: true });
      const m = new THREE.Mesh(geo, mat);
      m.userData.onClick = onClick;
      m.userData.label = label;
      vrButtons.push(m);
      return m;
    }

    function layoutVRPanel() {
      const panel = new THREE.Group();
      const titleTex = makeCanvasLabel('å±•é–‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸æŠ', 512, 64);
      const title = new THREE.Mesh(new THREE.PlaneGeometry(1.8, 0.22), new THREE.MeshBasicMaterial({ map: titleTex, transparent: true }));
      title.position.set(0, 0.9, 0);
      panel.add(title);

      // ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒœã‚¿ãƒ³ï¼ˆ2åˆ—Ã—6è¡Œï¼‰
      const buttons = patternNames.map((name, idx) => makeVRButton(name, () => {
        // HTMLãƒœã‚¿ãƒ³ã¨åŒã˜æŒ™å‹•
        currentPattern = idx;
        document.getElementById('currentPattern').textContent = `ç¾åœ¨: ${patternNames[idx]}`;
        // HTMLå´ã®activeã‚‚åŒæœŸ
        document.querySelectorAll('.pattern-btn').forEach((b, i) => {
          b.classList.toggle('active', i === idx);
        });
        setProgress(currentProgress);
      }));

      const cols = 2, dx = 0.7, dy = 0.22;
      buttons.forEach((b, i) => {
        const row = Math.floor(i/cols);
        const col = i%cols;
        b.position.set((col-0.5)*dx, 0.65 - row*dy, 0);
        panel.add(b);
      });

      // æ“ä½œç”¨ãƒœã‚¿ãƒ³ï¼ˆå±•é–‹/é–‰ã˜ã‚‹/ãƒªã‚»ãƒƒãƒˆï¼‰
      const unfoldB = makeVRButton('å±•é–‹', () => animateTo(1));
      const foldB   = makeVRButton('é–‰ã˜ã‚‹', () => animateTo(0));
      const resetB  = makeVRButton('ãƒªã‚»ãƒƒãƒˆ', () => {
        setProgress(0);
        document.getElementById('progressSlider').value = 0;
        document.getElementById('progressValue').textContent = '0';
      });
      unfoldB.position.set(-0.7, -0.9, 0);
      foldB.position.set(0.0, -0.9, 0);
      resetB.position.set(0.7, -0.9, 0);
      panel.add(unfoldB, foldB, resetB);

      // ãƒ‘ãƒãƒ«ã®ä½ç½®ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰è¦‹ã¦å·¦æ‰‹å´ï¼‰
      panel.position.set(-1.4, 1.2, 0);
      panel.rotation.y = 0.15;
      vrUIRoot.add(panel);
    }
    // layoutVRPanel() ã¯ patternNames å®šç¾©å¾Œã«å‘¼ã³å‡ºã—ã¾ã™ï¼ˆæœªå®šç¾©å‚ç…§ã‚’é˜²ãï¼‰
    // layoutVRPanel();
    

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(5, 5, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(renderer.domElement);
    // Moduleã‚¹ã‚¯ãƒªãƒ—ãƒˆã‹ã‚‰å‚ç…§ã§ãã‚‹ã‚ˆã†ã«windowã¸å…¬é–‹
    window.THREE = THREE;
    window.renderer = renderer;
    window.scene = scene;

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 5);
    scene.add(directionalLight);

    const gridHelper = new THREE.GridHelper(15, 15, 0xcccccc, 0xeeeeee);
    gridHelper.position.y = 0;
    stage.add(gridHelper);
    // VRå…¥å®¤æ™‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼åŸç‚¹(0,0,0)ã®ç´„3må‰ã«é…ç½®
    stage.position.set(0, 0, -3);
    // ã»ã‚“ã®å°‘ã—ã ã‘å³å‘ãã«å›ã—ã¦è¦‹ã‚„ã™ã
    stage.rotation.y = 0.25;

    // è‰²å®šç¾©
    const colors = {
      bottom: 0x0066ff,
      top: 0x0fffff,
      front: 0xff0000,
      back: 0x00cc00,
      left: 0xffcc00,
      right: 0x9933ff
    };

    const closedCube = {
      bottom: [[-1,0,-1], [1,0,-1], [1,0,1], [-1,0,1]],
      left:   [[-1,0,-1], [-1,0,1], [-1,2,1], [-1,2,-1]],
      right:  [[1,0,-1], [1,0,1], [1,2,1], [1,2,-1]],
      back:   [[-1,0,1], [1,0,1], [1,2,1], [-1,2,1]],
      front:  [[-1,0,-1], [1,0,-1], [1,2,-1], [-1,2,-1]],
      top:    [[-1,2,-1], [1,2,-1], [1,2,1], [-1,2,1]]
    };

    const faces = {};
    let currentProgress = 0;
    let currentPattern = 0;

    for (const [name, verts] of Object.entries(closedCube)) {
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(verts.flat());
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setIndex([0, 1, 2, 0, 2, 3]);
      geometry.computeVertexNormals();

      const material = new THREE.MeshStandardMaterial({
        color: colors[name],
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.9
      });

      const mesh = new THREE.Mesh(geometry, material);
      const edges = new THREE.LineSegments(
        new THREE.EdgesGeometry(geometry),
        new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
      );
      mesh.add(edges);
      stage.add(mesh);
      faces[name] = mesh;
    }

    function updateVertices(name, verts) {
      const pos = faces[name].geometry.attributes.position;
      verts.forEach((v, i) => {
        pos.array[i * 3] = v[0];
        pos.array[i * 3 + 1] = v[1];
        pos.array[i * 3 + 2] = v[2];
      });
      pos.needsUpdate = true;
      faces[name].geometry.computeVertexNormals();
    }

    function rotX(point, pivot, deg) {
      const rad = deg * Math.PI / 180;
      const [px, py, pz] = point;
      const [vx, vy, vz] = pivot;
      const dx = px - vx, dy = py - vy, dz = pz - vz;
      const c = Math.cos(rad), s = Math.sin(rad);
      return [dx + vx, dy * c - dz * s + vy, dy * s + dz * c + vz];
    }

    function rotZ(point, pivot, deg) {
      const rad = deg * Math.PI / 180;
      const [px, py, pz] = point;
      const [vx, vy, vz] = pivot;
      const dx = px - vx, dy = py - vy, dz = pz - vz;
      const c = Math.cos(rad), s = Math.sin(rad);
      return [dx * c - dy * s + vx, dx * s + dy * c + vy, dz + vz];
    }

    function rotateAroundEdge(point, edgeP1, edgeP2, deg) {
      const rad = deg * Math.PI / 180;
      const [px, py, pz] = point;
      const [e1x, e1y, e1z] = edgeP1;
      const [e2x, e2y, e2z] = edgeP2;
      const axisX = e2x - e1x, axisY = e2y - e1y, axisZ = e2z - e1z;
      const axisLen = Math.sqrt(axisX*axisX + axisY*axisY + axisZ*axisZ);
      const ax = axisX / axisLen, ay = axisY / axisLen, az = axisZ / axisLen;
      const dx = px - e1x, dy = py - e1y, dz = pz - e1z;
      const c = Math.cos(rad), s = Math.sin(rad), t = 1 - c;
      const rx = (t*ax*ax + c)*dx + (t*ax*ay - s*az)*dy + (t*ax*az + s*ay)*dz;
      const ry = (t*ax*ay + s*az)*dx + (t*ay*ay + c)*dy + (t*ay*az - s*ax)*dz;
      const rz = (t*ax*az - s*ay)*dx + (t*ay*az + s*ax)*dy + (t*az*az + c)*dz;
      return [rx + e1x, ry + e1y, rz + e1z];
    }

    function unfold1_4_1_A(t) {
      const angle = t * 90;
      const frontVerts = closedCube.front;
      updateVertices('front', closedCube.front);
      const leftVerts = closedCube.left.map(v => rotateAroundEdge(v, [-1,0,-1], [-1,2,-1], -angle));
      updateVertices('left', leftVerts);
      const rightVerts = closedCube.right.map(v => rotateAroundEdge(v, frontVerts[1], frontVerts[2], angle));
      updateVertices('right', rightVerts);
      const backStep1 = closedCube.back.map(v => rotateAroundEdge(v, [1,0,-1], [1,2,-1], angle));
      const backVerts = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[2], angle));
      updateVertices('back', backVerts);
      const topVerts = closedCube.top.map(v => rotateAroundEdge(v, [-1,2,-1], [1,2,-1], -angle));
      updateVertices('top', topVerts);
      const bottomVerts = closedCube.bottom.map(v => rotateAroundEdge(v, [-1,0,-1], [1,0,-1], angle));
      updateVertices('bottom', bottomVerts);
    }

    function unfold1_4_1_B(t) {
      const angle = t * 90;
      updateVertices('front', closedCube.front);
      const leftVerts = closedCube.left.map(v => rotateAroundEdge(v, [-1,0,-1], [-1,2,-1], -angle));
      updateVertices('left', leftVerts);
      const rightVerts = closedCube.right.map(v => rotateAroundEdge(v, [1,0,-1], [1,2,-1], angle));
      updateVertices('right', rightVerts);
      const backStep1 = closedCube.back.map(v => rotateAroundEdge(v, [1,0,-1], [1,2,-1], angle));
      const backVerts = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[2], angle));
      updateVertices('back', backVerts);
      const topStep3 = closedCube.top.map(v => rotateAroundEdge(v, [-1,0,-1], [-1,2,-1], -angle));
      const topVerts = topStep3.map(v => rotateAroundEdge(v, leftVerts[2], leftVerts[3], -angle));
      updateVertices('top', topVerts);
      const bottomVerts = closedCube.bottom.map(v => rotateAroundEdge(v, [-1,0,-1], [1,0,-1], angle));
      updateVertices('bottom', bottomVerts);
    }

    function unfold1_4_1_C(t) {
      const angle = t * 90;
      updateVertices('front', closedCube.front);
      const leftVerts = closedCube.left.map(v => rotateAroundEdge(v, [-1,0,-1], [-1,2,-1], -angle));
      updateVertices('left', leftVerts);
      const rightVerts = closedCube.right.map(v => rotateAroundEdge(v, [1,0,-1], [1,2,-1], angle));
      updateVertices('right', rightVerts);
      const backStep1 = closedCube.back.map(v => rotateAroundEdge(v, [1,0,-1], [1,2,-1], angle));
      const backVerts = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[2], angle));
      updateVertices('back', backVerts);
      const topStep3 = closedCube.top.map(v => rotateAroundEdge(v, [-1,0,-1], [-1,2,-1], -angle));
      const topVerts = topStep3.map(v => rotateAroundEdge(v, leftVerts[2], leftVerts[3], -angle));
      updateVertices('top', topVerts);
      const bottomStep1 = closedCube.bottom.map(v => rotateAroundEdge(v, [1,0,-1], [1,2,-1], angle));
      const bottomVerts = bottomStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
      updateVertices('bottom', bottomVerts);
    }

    function unfold1_4_1_D(t) {
      const angle = t * 90;
      const frontVerts = closedCube.front;
      updateVertices('front', closedCube.front);
      const leftVerts = closedCube.left.map(v => rotateAroundEdge(v, [-1,0,-1], [-1,2,-1], -angle));
      updateVertices('left', leftVerts);
      const rightVerts = closedCube.right.map(v => rotateAroundEdge(v, [1,0,-1], [1,2,-1], angle));
      updateVertices('right', rightVerts);
      const backStep1 = closedCube.back.map(v => rotateAroundEdge(v, [1,0,-1], [1,2,-1], angle));
      const backVerts = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[2], angle));
      updateVertices('back', backVerts);
      const topStep3 = closedCube.top.map(v => rotateAroundEdge(v, [-1,0,-1], [-1,2,-1], -angle));
      const topVerts = topStep3.map(v => rotateAroundEdge(v, leftVerts[2], leftVerts[3], -angle));
      updateVertices('top', topVerts);
      const bottomVerts = closedCube.bottom.map(v => rotateAroundEdge(v, backVerts[0], backVerts[1], -angle));
      updateVertices('bottom', bottomVerts);
    }

    function unfold1_4_1_E(t) {
      const angle = t * 90;
      updateVertices('bottom', closedCube.bottom);
      const leftVerts = closedCube.left.map(v => rotZ(v, [-1,0,-1], angle));
      updateVertices('left', leftVerts);
      const rightVerts = closedCube.right.map(v => rotZ(v, [1,0,-1], -angle));
      updateVertices('right', rightVerts);
      const backStep1 = closedCube.back.map(v => rotZ(v, [1,0,-1], -angle));
      const backVerts = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[2], -angle));
      updateVertices('back', backVerts);
      const frontVerts = closedCube.front.map(v => rotX(v, [-1,0,-1], -angle));
      updateVertices('front', frontVerts);
      const topVerts = closedCube.top.map(v => rotX(v, [-1,0,-1], -angle));
      updateVertices('top', topVerts);
    }

    function unfold1_4_1_F(t) {
      const angle = t * 90;
      updateVertices('bottom', closedCube.bottom);
      const leftVerts = closedCube.left.map(v => rotZ(v, [-1,0,-1], angle));
      updateVertices('left', leftVerts);
      const rightVerts = closedCube.right.map(v => rotZ(v, [1,0,-1], -angle));
      updateVertices('right', rightVerts);
      const backStep1 = closedCube.back.map(v => rotZ(v, [1,0,-1], -angle));
      const backVerts = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[2], -angle));
      updateVertices('back', backVerts);
      const frontVerts = closedCube.front.map(v => rotX(v, [-1,0,-1], -angle));
      updateVertices('front', frontVerts);
      const topStep1 = closedCube.top.map(v => rotZ(v, [1,0,-1], -angle));
      const topVerts = topStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
      updateVertices('top', topVerts);
    }

    function unfold1_3_2_G(t) {
      const angle = t * 90;
      updateVertices('bottom', closedCube.bottom);
      const leftVerts = closedCube.left.map(v => rotZ(v, [-1,0,-1], angle));
      updateVertices('left', leftVerts);
      const rightVerts = closedCube.right.map(v => rotZ(v, [1,0,-1], -angle));
      updateVertices('right', rightVerts);
      const frontStep1 = closedCube.front.map(v => rotZ(v, [-1,0,-1], angle));
      const frontVerts = frontStep1.map(v => rotateAroundEdge(v, leftVerts[2], leftVerts[3], angle));
      updateVertices('front', frontVerts);
      const topStep1 = closedCube.top.map(v => rotZ(v, [1,0,-1], -angle));
      const topVerts = topStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
      updateVertices('top', topVerts);
      const backStep1 = closedCube.back.map(v => rotZ(v, [1,0,-1], -angle));
      const backStep2 = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
      const backVerts = backStep2.map(v => rotateAroundEdge(v, topVerts[1], topVerts[2], -angle));
      updateVertices('back', backVerts);
    }

    function unfold1_3_2_H(t) {
      const angle = t * 90;
      updateVertices('bottom', closedCube.bottom);
      const leftVerts = closedCube.left.map(v => rotZ(v, [-1,0,-1], angle));
      updateVertices('left', leftVerts);
      const rightVerts = closedCube.right.map(v => rotZ(v, [1,0,-1], -angle));
      updateVertices('right', rightVerts);
      const frontVerts = closedCube.front.map(v => rotX(v, [-1,0,-1], -angle));
      updateVertices('front', frontVerts);
      const topStep1 = closedCube.top.map(v => rotZ(v, [1,0,-1], -angle));
      const topVerts = topStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
      updateVertices('top', topVerts);
      const backStep1 = closedCube.back.map(v => rotZ(v, [1,0,-1], -angle));
      const backStep2 = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
      const backVerts = backStep2.map(v => rotateAroundEdge(v, topVerts[1], topVerts[2], -angle));
      updateVertices('back', backVerts);
    }

    function unfold1_3_2_I(t) {
      const angle = t * 90;
      updateVertices('bottom', closedCube.bottom);
      const leftVerts = closedCube.left.map(v => rotZ(v, [-1,0,-1], angle));
      updateVertices('left', leftVerts);
      const rightVerts = closedCube.right.map(v => rotZ(v, [1,0,-1], -angle));
      updateVertices('right', rightVerts);
      const frontStep1 = closedCube.front.map(v => rotZ(v, [1,0,-1], -angle));
      const frontVerts = frontStep1.map(v => rotateAroundEdge(v, rightVerts[2], rightVerts[3], angle));
      updateVertices('front', frontVerts);
      const topStep1 = closedCube.top.map(v => rotZ(v, [1,0,-1], -angle));
      const topVerts = topStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
      updateVertices('top', topVerts);
      const backStep1 = closedCube.back.map(v => rotZ(v, [1,0,-1], -angle));
      const backStep2 = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
      const backVerts = backStep2.map(v => rotateAroundEdge(v, topVerts[1], topVerts[2], -angle));
      updateVertices('back', backVerts);
    }

    function unfold3_3_J(t) {
      const angle = t * 90;
      updateVertices('bottom', closedCube.bottom);
      const rightVerts = closedCube.right.map(v => rotZ(v, [1,0,-1], angle));
      updateVertices('right', rightVerts);
      const backStep1 = closedCube.back.map(v => rotZ(v, [1,0,-1], angle));
      const backVerts = backStep1.map(v => rotateAroundEdge(v, rightVerts[0], rightVerts[3], angle));
      updateVertices('back', backVerts);
      const frontVerts = closedCube.front.map(v => rotX(v, [1,0,-1], angle));
      updateVertices('front', frontVerts);
      const leftStep1 = closedCube.left.map(v => rotX(v, [1,0,-1], angle));
      const leftVerts = leftStep1.map(v => rotateAroundEdge(v, frontVerts[1], frontVerts[2], angle));
      updateVertices('left', leftVerts);
      const topStep1 = closedCube.top.map(v => rotX(v, [1,0,-1], angle));
      const topStep2 = topStep1.map(v => rotateAroundEdge(v, frontVerts[1], frontVerts[2], angle));
      const topVerts = topStep2.map(v => rotateAroundEdge(v, leftVerts[1], leftVerts[2], angle));
      updateVertices('top', topVerts);
    }

    function unfold2_2_2_K(t) {
      const angle = t * 90;
      updateVertices('bottom', closedCube.bottom);
      const frontVerts = closedCube.front.map(v => rotX(v, [-1,0,-1], -angle));
      updateVertices('front', frontVerts);
      const leftStep1 = closedCube.left.map(v => rotX(v, [-1,0,-1], -angle));
      const leftVerts = leftStep1.map(v => rotateAroundEdge(v, frontVerts[0], frontVerts[3], -angle));
      updateVertices('left', leftVerts);
      const rightVerts = closedCube.right.map(v => rotZ(v, [1,0,-1], -angle));
      updateVertices('right', rightVerts);
      const topStep1 = closedCube.top.map(v => rotZ(v, [1,0,-1], -angle));
      const topVerts = topStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
      updateVertices('top', topVerts);
      const backStep1 = closedCube.back.map(v => rotZ(v, [1,0,-1], -angle));
      const backStep2 = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
      const backVerts = backStep2.map(v => rotateAroundEdge(v, topVerts[1], topVerts[2], -angle));
      updateVertices('back', backVerts);
    }

    function setProgress(p) {
      currentProgress = p;
      const unfoldFunctions = [
        unfold1_4_1_A,
        unfold1_4_1_B,
        unfold1_4_1_C,
        unfold1_4_1_D,
        unfold1_4_1_E,
        unfold1_4_1_F,
        unfold1_3_2_G,
        unfold1_3_2_H,
        unfold1_3_2_I,
        unfold3_3_J,
        unfold2_2_2_K
      ];
      unfoldFunctions[currentPattern](p);
    }

    function animateTo(target) {
      const start = currentProgress;
      const startTime = Date.now();
      const anim = () => {
        const elapsed = Date.now() - startTime;
        const t = Math.min(elapsed / 2000, 1);
        const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        const p = start + (target - start) * eased;
        setProgress(p);
        document.getElementById('progressSlider').value = Math.round(p * 100);
        document.getElementById('progressValue').textContent = Math.round(p * 100);
        if (t < 1) requestAnimationFrame(anim);
      };
      anim();
    }

    const patternNames = [
      'A. 1-4-1å‹A (åå­—å‹)', 'B. 1-4-1å‹B (å¸¯å‹1)', 'C. 1-4-1å‹C (Lå­—å‹)',
      'D. 1-4-1å‹D (Lå­—å¤‰å½¢1)', 'E. 1-4-1å‹E (Tå­—å‹)', 'F. 1-4-1å‹F (å¸¯å‹2)',
      'G. 1-3-2å‹G (ã‚¸ã‚°ã‚¶ã‚°å‹)', 'H. 1-3-2å‹H (Wå­—å‹)', 'I. 1-3-2å‹I (éšæ®µå‹)',
      'J. 3-3å‹J (ãƒ—ãƒ­ãƒšãƒ©å‹)', 'K. 2-2-2å‹K (éšæ®µå‹2)'
    ];

    // â† ã“ã“ã§åˆã‚ã¦VR UIã‚’ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆpatternNamesã«ä¾å­˜ã™ã‚‹ãŸã‚ï¼‰
    try { layoutVRPanel(); } catch(e) { console.error('layoutVRPanel failed:', e); }


    document.querySelectorAll('.pattern-btn').forEach(btn => {
      btn.onclick = () => {
        document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const id = parseInt(btn.dataset.pattern);
        currentPattern = id;
        document.getElementById('currentPattern').textContent = `ç¾åœ¨: ${patternNames[id]}`;
        setProgress(currentProgress);
      };
    });

    document.getElementById('unfoldBtn').onclick = () => animateTo(1);
    document.getElementById('foldBtn').onclick = () => animateTo(0);
    document.getElementById('resetBtn').onclick = () => {
      setProgress(0);
      document.getElementById('progressSlider').value = 0;
      document.getElementById('progressValue').textContent = '0';
    };
    document.getElementById('progressSlider').oninput = e => {
      setProgress(e.target.value / 100);
      document.getElementById('progressValue').textContent = e.target.value;
    };

    // === ãƒã‚¦ã‚¹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« ===
    let drag = false, prev = { x: 0, y: 0 }, rot = { x: 0.4, y: 0.6 };
    renderer.domElement.onmousedown = e => { drag = true; prev = { x: e.clientX, y: e.clientY }; };
    renderer.domElement.onmousemove = e => {
      if (drag) {
        rot.y += (e.clientX - prev.x) * 0.005;
        rot.x += (e.clientY - prev.y) * 0.005;
        prev = { x: e.clientX, y: e.clientY };
      }
    };
    renderer.domElement.onmouseup = () => (drag = false);
    renderer.domElement.onwheel = e => {
      e.preventDefault();
      camera.position.z = Math.max(4, Math.min(20, camera.position.z + e.deltaY * 0.01));
    };

    window.onresize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };

    // === ã‚«ãƒ¡ãƒ©ã®å‘¨å› & ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° ===
    function renderFrame() {
      // VRä¸­ã¯ãƒ˜ãƒƒãƒ‰ã‚»ãƒƒãƒˆã®å§¿å‹¢ã«ä»»ã›ã€ã‚«ãƒ¡ãƒ©åº§æ¨™ã¯ä¸Šæ›¸ãã—ãªã„
      if (!renderer.xr.isPresenting) {
        const r = camera.position.length();
        camera.position.set(
          r * Math.sin(rot.y) * Math.cos(rot.x),
          r * Math.sin(rot.x),
          r * Math.cos(rot.y) * Math.cos(rot.x)
        );
        camera.lookAt(0, 1, 0);
      } else {
        updateVRIntersections();
      }
      renderer.render(scene, camera);
    }
    // setAnimationLoop ã¯é€šå¸¸æ™‚ã‚‚å‹•ä½œã—ã€VRã‚»ãƒƒã‚·ãƒ§ãƒ³ä¸­ã¯XRã®ã‚¿ã‚¤ãƒ ã‚¹ãƒ†ãƒƒãƒ—ã§å‘¼ã°ã‚Œã¾ã™
    renderer.setAnimationLoop(renderFrame);

    // === Raycaster for VR button interaction ===
    const raycaster = new THREE.Raycaster();
    const tempMatrix = new THREE.Matrix4();

    function updateVRIntersections() {
      if (!renderer.xr.isPresenting || !window.__controllers) return;
      let newHover = null;
      for (const c of window.__controllers) {
        if (!c) continue;
        tempMatrix.identity().extractRotation(c.matrixWorld);
        raycaster.ray.origin.setFromMatrixPosition(c.matrixWorld);
        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
        const intersects = raycaster.intersectObjects(vrButtons, false);
        if (intersects.length > 0) {
          newHover = intersects[0].object;
          if (c.userData.selecting && newHover.userData.onClick) {
            // ã‚¯ãƒªãƒƒã‚¯
            newHover.userData.onClick();
            c.userData.selecting = false; // å˜ç™º
          }
        }
      }
      if (vrHovered !== newHover) {
        if (vrHovered) vrHovered.material.opacity = 1.0;
        vrHovered = newHover;
        if (vrHovered) vrHovered.material.opacity = 0.7;
      }
    }
  </script>

  <!-- WebXRã®æœ‰åŠ¹åŒ–ã¨VRButtonã®è¨­ç½®ï¼ˆmoduleã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼‰ -->
  <script type="module">
    import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/XRControllerModelFactory.js';

    // é‡è¦: module ã‹ã‚‰ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ã‚ã‚‹ window.renderer ã‚’å‚ç…§ã™ã‚‹
    const renderer = window.renderer;

    if (!renderer) {
      console.error('[WebXR] renderer ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚module ã‹ã‚‰ window.renderer ã‚’å…¬é–‹ã—ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
    } else {
      renderer.xr.enabled = true;
      document.body.appendChild(VRButton.createButton(renderer));

      // === ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©å¯è¦–åŒ– & ãƒ¬ã‚¤ ===
      const factory = new XRControllerModelFactory();
      window.__controllers = [];

      for (let i = 0; i < 2; i++) {
        const controller = renderer.xr.getController(i);
        controller.addEventListener('selectstart', () => controller.userData.selecting = true);
        controller.addEventListener('selectend',   () => controller.userData.selecting = false);

        const lineGeom = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -2)
        ]);
        const line = new THREE.Line(lineGeom, new THREE.LineBasicMaterial({ linewidth: 2 }));
        line.name = 'ray';
        controller.add(line);
        window.scene.add(controller);

        const grip = renderer.xr.getControllerGrip(i);
        grip.add(factory.createControllerModel(grip));
        window.scene.add(grip);

        window.__controllers[i] = controller;
      }
    }
  </script>
</body>
</html>
