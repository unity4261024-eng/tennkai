<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç«‹æ–¹ä½“ã®å±•é–‹å›³ - å®Œå…¨ä¿®æ­£ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            transition: all 0.3s ease;
        }
        #controlsHeader {
            padding: 15px 20px;
            cursor: pointer;
            user-select: none;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #controlsHeader:hover {
            background: linear-gradient(135deg, #7c8eeb 0%, #8757ad 100%);
        }
        #controlsHeader h2 {
            margin: 0;
            font-size: 18px;
        }
        #toggleIcon {
            font-size: 20px;
            transition: transform 0.3s ease;
        }
        #toggleIcon.expanded {
            transform: rotate(180deg);
        }
        #controlsContent {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        #controlsContent.expanded {
            max-height: 600px;
        }
        #controlsInner {
            padding: 20px;
        }
        .pattern-section {
            margin-bottom: 20px;
        }
        .pattern-section h3 {
            margin: 10px 0 5px 0;
            color: #666;
            font-size: 14px;
        }
        .button-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        button {
            padding: 10px 16px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
            transition: all 0.2s;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        button:active {
            transform: scale(0.95);
        }
        button.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        .control-buttons {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }
        .control-buttons button {
            flex: 1;
        }
        .slider-container {
            margin: 15px 0;
        }
        .slider-container label {
            display: block;
            margin-bottom: 5px;
            color: #666;
            font-weight: bold;
        }
        input[type="range"] {
            width: 100%;
        }
        #progressValue {
            display: inline-block;
            width: 40px;
            text-align: right;
            color: #667eea;
            font-weight: bold;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
        }
        #currentPattern {
            font-weight: bold;
            color: #ffd93d;
            font-size: 16px;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="controls">
        <div id="controlsHeader">
            <h2>ğŸ² ç«‹æ–¹ä½“ã®å±•é–‹å›³ï¼ˆå®Œå…¨ç‰ˆï¼‰</h2>
            <span id="toggleIcon">â–¼</span>
        </div>
        <div id="controlsContent">
            <div id="controlsInner">
                <div class="pattern-section">
                    <h3>ğŸ“‹ å±•é–‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸æŠ</h3>
                    <div class="button-grid">
                        <button class="pattern-btn active" data-pattern="0">A. 1-4-1å‹A (åå­—å‹)</button>
                        <button class="pattern-btn" data-pattern="1">B. 1-4-1å‹B (å¸¯å‹1)</button>
                        <button class="pattern-btn" data-pattern="2">C. 1-4-1å‹C (Lå­—å‹)</button>
                        <button class="pattern-btn" data-pattern="3">D. 1-4-1å‹D (Lå­—å¤‰å½¢1)</button>
                        <button class="pattern-btn" data-pattern="4">E. 1-4-1å‹E (Tå­—å‹)</button>
                        <button class="pattern-btn" data-pattern="5">F. 1-4-1å‹F (å¸¯å‹2)</button>
                        <button class="pattern-btn" data-pattern="6">G. 1-3-2å‹G (ã‚¸ã‚°ã‚¶ã‚°å‹)</button>
                        <button class="pattern-btn" data-pattern="7">H. 1-3-2å‹H (Wå­—å‹)</button>
                        <button class="pattern-btn" data-pattern="8">I. 1-3-2å‹I (éšæ®µå‹)</button>
                        <button class="pattern-btn" data-pattern="9">J. 3-3å‹J (ãƒ—ãƒ­ãƒšãƒ©å‹)</button>
                        <button class="pattern-btn" data-pattern="10">K. 2-2-2å‹K (éšæ®µå‹2)</button>
                    </div>
                </div>
                
                <div class="control-buttons">
                    <button id="unfoldBtn">å±•é–‹</button>
                    <button id="foldBtn">é–‰ã˜ã‚‹</button>
                    <button id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
                </div>
                
                <div class="slider-container">
                    <label>å±•é–‹åº¦: <span id="progressValue">0</span>%</label>
                    <input type="range" id="progressSlider" min="0" max="100" value="0">
                </div>
            </div>
        </div>
    </div>
    
    <div id="info">
        <div id="currentPattern">ç¾åœ¨: A. 1-4-1å‹A (åå­—å‹)</div>
        ğŸ’¡ ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°ã§å›è»¢<br>
        ğŸ–±ï¸ ãƒ›ã‚¤ãƒ¼ãƒ«ã§æ‹¡å¤§ç¸®å°<br>
        ğŸ”— æ­£ã—ã„å¯¾é¢é–¢ä¿‚ã§å±•é–‹
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ«ã®é–‹é–‰
        const controlsHeader = document.getElementById('controlsHeader');
        const controlsContent = document.getElementById('controlsContent');
        const toggleIcon = document.getElementById('toggleIcon');
        let isExpanded = false;
        
        controlsHeader.addEventListener('click', () => {
            isExpanded = !isExpanded;
            if (isExpanded) {
                controlsContent.classList.add('expanded');
                toggleIcon.classList.add('expanded');
            } else {
                controlsContent.classList.remove('expanded');
                toggleIcon.classList.remove('expanded');
            }
        });
        
        // Three.js ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 8);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);
        
        const gridHelper = new THREE.GridHelper(15, 15, 0xcccccc, 0xeeeeee);
        gridHelper.position.y = 0;
        scene.add(gridHelper);
        
        // ç«‹æ–¹ä½“ã®è‰²å®šç¾©ï¼ˆæ­£ã—ã„å¯¾é¢é–¢ä¿‚ï¼‰
        // é’ï¼ˆåº•é¢ï¼‰â†” ç™½ï¼ˆå¤©é¢ï¼‰ã€èµ¤ï¼ˆå‰é¢ï¼‰â†” ç·‘ï¼ˆå¾Œé¢ï¼‰ã€é»„ï¼ˆå·¦é¢ï¼‰â†” ç´«ï¼ˆå³é¢ï¼‰
        const colors = {
            bottom: 0x0066ff,  // é’ï¼ˆåº•é¢ï¼‰
            top: 0x0fffff,     // ç™½ï¼ˆå¤©é¢ï¼‰â†’æ°´è‰²
            front: 0xff0000,   // èµ¤ï¼ˆå‰é¢ï¼‰â† å±•é–‹å›³ã®ä¸­å¤®
            back: 0x00cc00,    // ç·‘ï¼ˆå¾Œé¢ï¼‰
            left: 0xffcc00,    // é»„ï¼ˆå·¦é¢ï¼‰
            right: 0x9933ff    // ç´«ï¼ˆå³é¢ï¼‰
        };
        
        // é–‰ã˜ãŸçŠ¶æ…‹ã®ç«‹æ–¹ä½“ã®é ‚ç‚¹
        const closedCube = {
            bottom: [[-1,0,-1], [1,0,-1], [1,0,1], [-1,0,1]],        // èµ¤ï¼ˆä¸­å¤®ï¼‰
            left:   [[-1,0,-1], [-1,0,1], [-1,2,1], [-1,2,-1]],      // é»„ï¼ˆå·¦ï¼‰
            right:  [[1,0,-1], [1,0,1], [1,2,1], [1,2,-1]],          // ç´«ï¼ˆå³ï¼‰
            back:   [[-1,0,1], [1,0,1], [1,2,1], [-1,2,1]],          // ç·‘ï¼ˆå¾Œï¼‰
            front:  [[-1,0,-1], [1,0,-1], [1,2,-1], [-1,2,-1]],      // ç™½
            top:    [[-1,2,-1], [1,2,-1], [1,2,1], [-1,2,1]]         // é’
        };
        
        const faces = {};
        let currentProgress = 0;
        let currentPattern = 0;
        
        // å„é¢ã‚’ä½œæˆ
        for (const [name, verts] of Object.entries(closedCube)) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(verts.flat());
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setIndex([0, 1, 2, 0, 2, 3]);
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshStandardMaterial({
                color: colors[name],
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            const edges = new THREE.LineSegments(
                new THREE.EdgesGeometry(geometry),
                new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
            );
            mesh.add(edges);
            scene.add(mesh);
            
            faces[name] = mesh;
        }
        
        function updateVertices(name, verts) {
            const pos = faces[name].geometry.attributes.position;
            verts.forEach((v, i) => {
                pos.array[i * 3] = v[0];
                pos.array[i * 3 + 1] = v[1];
                pos.array[i * 3 + 2] = v[2];
            });
            pos.needsUpdate = true;
            faces[name].geometry.computeVertexNormals();
        }
        
        // Xè»¸å‘¨ã‚Šã®å›è»¢ï¼ˆå¼•æ•°ã¯åº¦ï¼‰
        function rotX(point, pivot, deg) {
            const rad = deg * Math.PI / 180;
            const [px, py, pz] = point;
            const [vx, vy, vz] = pivot;
            const dx = px - vx, dy = py - vy, dz = pz - vz;
            const c = Math.cos(rad), s = Math.sin(rad);
            return [
                dx + vx,
                dy * c - dz * s + vy,
                dy * s + dz * c + vz
            ];
        }
        
        // Zè»¸å‘¨ã‚Šã®å›è»¢
        function rotZ(point, pivot, deg) {
            const rad = deg * Math.PI / 180;
            const [px, py, pz] = point;
            const [vx, vy, vz] = pivot;
            const dx = px - vx, dy = py - vy, dz = pz - vz;
            const c = Math.cos(rad), s = Math.sin(rad);
            return [
                dx * c - dy * s + vx,
                dx * s + dy * c + vy,
                dz + vz
            ];
        }
        
        // ä»»æ„ã®è¾ºï¼ˆ2ç‚¹ã‚’çµã¶ç›´ç·šï¼‰ã‚’è»¸ã«å›è»¢
        function rotateAroundEdge(point, edgeP1, edgeP2, deg) {
            const rad = deg * Math.PI / 180;
            const [px, py, pz] = point;
            const [e1x, e1y, e1z] = edgeP1;
            const [e2x, e2y, e2z] = edgeP2;
            
            // è»¸ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’æ­£è¦åŒ–
            const axisX = e2x - e1x;
            const axisY = e2y - e1y;
            const axisZ = e2z - e1z;
            const axisLen = Math.sqrt(axisX*axisX + axisY*axisY + axisZ*axisZ);
            const ax = axisX / axisLen;
            const ay = axisY / axisLen;
            const az = axisZ / axisLen;
            
            // ç‚¹ã‚’edgeP1ã‚’åŸç‚¹ã¨ã™ã‚‹åº§æ¨™ç³»ã«å¤‰æ›
            const dx = px - e1x;
            const dy = py - e1y;
            const dz = pz - e1z;
            
            // ãƒ­ãƒ‰ãƒªã‚²ã‚¹ã®å›è»¢å…¬å¼
            const c = Math.cos(rad);
            const s = Math.sin(rad);
            const t = 1 - c;
            
            const rx = (t*ax*ax + c)*dx + (t*ax*ay - s*az)*dy + (t*ax*az + s*ay)*dz;
            const ry = (t*ax*ay + s*az)*dx + (t*ay*ay + c)*dy + (t*ay*az - s*ax)*dz;
            const rz = (t*ax*az - s*ay)*dx + (t*ay*az + s*ax)*dy + (t*az*az + c)*dz;
            
            return [rx + e1x, ry + e1y, rz + e1z];
        }
        
        
        // 1-4-1å‹ã®å±•é–‹é–¢æ•°ï¼ˆèµ¤ï¼ˆå‰é¢ï¼‰ã‚’å›ºå®šï¼‰
        function unfold1_4_1_A(t) {
            // A. 1-4-1å‹A (åå­—å‹) ç™½(ä¸Š) - é»„/èµ¤/ç´«/ç·‘ - é’(ä¸‹)
            const angle = t * 90;
            const frontVerts = closedCube.front;
            updateVertices('front', closedCube.front); // èµ¤ï¼ˆå‰é¢ï¼‰å›ºå®š
            
            // é»„ã‚’èµ¤ã®å·¦è¾ºã‚’è»¸ã«å›è»¢ã—ã¦å·¦ã«å±•é–‹
            const leftVerts = closedCube.left.map(v => rotateAroundEdge(v, [-1, 0, -1], [-1, 2, -1], -angle));
            updateVertices('left', leftVerts);
            
            // ç´«ã‚’èµ¤ã®å³è¾ºã‚’è»¸ã«å›è»¢ã—ã¦å³ã«å±•é–‹
            const rightVerts = closedCube.right.map(v => rotateAroundEdge(v, frontVerts[1], frontVerts[2], angle));
            updateVertices('right', rightVerts);
            
            // ç·‘ã‚’ç´«ã®å³è¾ºã‚’è»¸ã«å›è»¢ã—ã¦ç´«ã®å³éš£ã«å±•é–‹
            const backStep1 = closedCube.back.map(v => rotateAroundEdge(v, [1, 0, -1], [1, 2, -1], angle));
            const backVerts = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[2], angle));
            updateVertices('back', backVerts);
            
            // ç™½ã‚’èµ¤ã®ä¸Šè¾ºã‚’è»¸ã«å›è»¢ã—ã¦ä¸Šã«å±•é–‹
            const topVerts = closedCube.top.map(v => rotateAroundEdge(v, [-1, 2, -1], [1, 2, -1], -angle));
            updateVertices('top', topVerts);
            
            // é’ã‚’èµ¤ã®ä¸‹è¾ºã‚’è»¸ã«å›è»¢ã—ã¦ä¸‹ã«å±•é–‹
            const bottomVerts = closedCube.bottom.map(v => rotateAroundEdge(v, [-1, 0, -1], [1, 0, -1], angle));
            updateVertices('bottom', bottomVerts);
        }
        
        function unfold1_4_1_B(t) {
            // B. 1-4-1å‹B (å¸¯å‹1) æ°´è‰²(èµ¤ä¸Š) - é»„/èµ¤/ç´«/ç·‘ - é’(èµ¤ä¸‹)
            const angle = t * 90;
            updateVertices('front', closedCube.front); // èµ¤ï¼ˆå‰é¢ï¼‰å›ºå®š
            
            // é»„ã‚’èµ¤ã®å·¦è¾ºã‚’è»¸ã«å›è»¢ã—ã¦å·¦ã«å±•é–‹
            const leftVerts = closedCube.left.map(v => rotateAroundEdge(v, [-1, 0, -1], [-1, 2, -1], -angle));
            updateVertices('left', leftVerts);
            
            // ç´«ã‚’èµ¤ã®å³è¾ºã‚’è»¸ã«å›è»¢ã—ã¦å³ã«å±•é–‹
            const rightVerts = closedCube.right.map(v => rotateAroundEdge(v, [1, 0, -1], [1, 2, -1], angle));
            updateVertices('right', rightVerts);
            
            // ç·‘ã‚’ç´«ã®å³è¾ºã‚’è»¸ã«å›è»¢ã—ã¦ç´«ã®å³éš£ã«å±•é–‹
            const backStep1 = closedCube.back.map(v => rotateAroundEdge(v, [1, 0, -1], [1, 2, -1], angle));
            const backVerts = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[2], angle));
            updateVertices('back', backVerts);
            
            // ç™½ã‚’èµ¤ã®ä¸Šè¾ºã‚’è»¸ã«å›è»¢ã—ã¦ä¸Šã«å±•é–‹
            const topStep3 = closedCube.top.map(v => rotateAroundEdge(v, [-1, 0, -1], [-1, 2, -1], -angle));
            const topVerts = topStep3.map(v => rotateAroundEdge(v, leftVerts[2], leftVerts[3], -angle));
            updateVertices('top', topVerts);

            
            
            // é’ã‚’èµ¤ã®ä¸‹è¾ºã‚’è»¸ã«å›è»¢ã—ã¦ä¸‹ã«å±•é–‹
            const bottomVerts = closedCube.bottom.map(v => rotateAroundEdge(v, [-1, 0, -1], [1, 0, -1], angle));
            updateVertices('bottom', bottomVerts);
        }
        
        function unfold1_4_1_C(t) {
            // C. 1-4-1å‹C (Lå­—å‹) æ°´(é»„ä¸Š) - é»„/èµ¤/ç´«/ç·‘ - é’(ç´«ä¸‹)
            const angle = t * 90;
            updateVertices('front', closedCube.front); // èµ¤ï¼ˆå‰é¢ï¼‰å›ºå®š
            
            // é»„ã‚’èµ¤ã®å·¦è¾ºã‚’è»¸ã«å›è»¢ã—ã¦å·¦ã«å±•é–‹
            const leftVerts = closedCube.left.map(v => rotateAroundEdge(v, [-1, 0, -1], [-1, 2, -1], -angle));
            updateVertices('left', leftVerts);
            
            // ç´«ã‚’èµ¤ã®å³è¾ºã‚’è»¸ã«å›è»¢ã—ã¦å³ã«å±•é–‹
            const rightVerts = closedCube.right.map(v => rotateAroundEdge(v, [1, 0, -1], [1, 2, -1], angle));
            updateVertices('right', rightVerts);
            
            // ç·‘ã‚’ç´«ã®å³è¾ºã‚’è»¸ã«å›è»¢ã—ã¦ç´«ã®å³éš£ã«å±•é–‹
            const backStep1 = closedCube.back.map(v => rotateAroundEdge(v, [1, 0, -1], [1, 2, -1], angle));
            const backVerts = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[2], angle));
            updateVertices('back', backVerts);
            
            // ç™½ã‚’èµ¤ã®ä¸Šè¾ºã‚’è»¸ã«å›è»¢ã—ã¦ä¸Šã«å±•é–‹
            const topStep3 = closedCube.top.map(v => rotateAroundEdge(v, [-1, 0, -1], [-1, 2, -1], -angle));
            const topVerts = topStep3.map(v => rotateAroundEdge(v, leftVerts[2], leftVerts[3], -angle));
            updateVertices('top', topVerts);

            // é’ã‚’ç´«ã®ä¸‹è¾ºã‚’è»¸ã«å›è»¢ã—ã¦ä¸‹ã«å±•é–‹
            const bottomStep1 = closedCube.bottom.map(v => rotateAroundEdge(v, [1, 0, -1], [1, 2, -1], angle));
            const bottomVerts = bottomStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
            updateVertices('bottom', bottomVerts);
        }
        
        function unfold1_4_1_D(t) {
            // D. 1-4-1å‹D (Lå­—å¤‰å½¢1) æ°´(é»„ä¸Š) - é»„/èµ¤/ç´«/ç·‘ - é’(ç·‘ä¸‹)
            const angle = t * 90;
            const frontVerts = closedCube.front;
            updateVertices('front', closedCube.front); // èµ¤ï¼ˆå‰é¢ï¼‰å›ºå®š
            
            // é»„ã‚’èµ¤ã®å·¦è¾ºã‚’è»¸ã«å›è»¢ã—ã¦å·¦ã«å±•é–‹
            const leftVerts = closedCube.left.map(v => rotateAroundEdge(v, [-1, 0, -1], [-1, 2, -1], -angle));
            updateVertices('left', leftVerts);
            
            // ç´«ã‚’èµ¤ã®å³è¾ºã‚’è»¸ã«å›è»¢ã—ã¦å³ã«å±•é–‹
            const rightVerts = closedCube.right.map(v => rotateAroundEdge(v, [1, 0, -1], [1, 2, -1], angle));
            updateVertices('right', rightVerts);
            
            // ç·‘ã‚’ç´«ã®å³è¾ºã‚’è»¸ã«å›è»¢ã—ã¦ç´«ã®å³éš£ã«å±•é–‹
            const backStep1 = closedCube.back.map(v => rotateAroundEdge(v, [1, 0, -1], [1, 2, -1], angle));
            const backVerts = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[2], angle));
            updateVertices('back', backVerts);
            
            // ç™½ã‚’èµ¤ã®ä¸Šè¾ºã‚’è»¸ã«å›è»¢ã—ã¦ä¸Šã«å±•é–‹
            const topStep3 = closedCube.top.map(v => rotateAroundEdge(v, [-1, 0, -1], [-1, 2, -1], -angle));
            const topVerts = topStep3.map(v => rotateAroundEdge(v, leftVerts[2], leftVerts[3], -angle));
            updateVertices('top', topVerts);

            // é’ã‚’ç·‘ã®ä¸‹è¾ºã‚’è»¸ã«å›è»¢ã—ã¦ä¸‹ã«å±•é–‹
            const bottomVerts = closedCube.bottom.map(v =>rotateAroundEdge(v, backVerts[0], backVerts[1], /*å‘ã*/ -angle));
            updateVertices('bottom', bottomVerts);
        }
        
        function unfold1_4_1_E(t) {
            // E. 1-4-1å‹E (Tå­—å‹) èµ¤(é’ä¸Š) - é»„/é’/ç´«/ç·‘ - ç™½(é’ä¸‹)
            const angle = t * 90;
            updateVertices('bottom', closedCube.bottom);
            
            const leftVerts = closedCube.left.map(v => rotZ(v, [-1, 0, -1], angle));
            updateVertices('left', leftVerts);
            
            const rightVerts = closedCube.right.map(v => rotZ(v, [1, 0, -1], -angle));
            updateVertices('right', rightVerts);
            
            // ç·‘ã‚’ç´«ã®å³éš£ã«å±•é–‹
            const backStep1 = closedCube.back.map(v => rotZ(v, [1, 0, -1], -angle));
            const backVerts = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[2], -angle));
            updateVertices('back', backVerts);
            
            // èµ¤ã‚’é’ã®ä¸Šã«é…ç½®
            const frontVerts = closedCube.front.map(v => rotX(v, [-1, 0, -1], -angle));
            updateVertices('front', frontVerts);
            
            // ç™½ã‚’é’ã®ä¸‹ã«é…ç½®
            const topVerts = closedCube.top.map(v => rotX(v, [-1, 0, -1], -angle));
            updateVertices('top', topVerts);
        }
        
        function unfold1_4_1_F(t) {
            // F. 1-4-1å‹F (å¸¯å‹2) èµ¤(é’ä¸Š) - é»„/é’/ç´«/ç·‘ - ç™½(ç´«ä¸‹)
            const angle = t * 90;
            updateVertices('bottom', closedCube.bottom);
            
            const leftVerts = closedCube.left.map(v => rotZ(v, [-1, 0, -1], angle));
            updateVertices('left', leftVerts);
            
            const rightVerts = closedCube.right.map(v => rotZ(v, [1, 0, -1], -angle));
            updateVertices('right', rightVerts);
            
            // ç·‘ã‚’ç´«ã®å³éš£ã«å±•é–‹
            const backStep1 = closedCube.back.map(v => rotZ(v, [1, 0, -1], -angle));
            const backVerts = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[2], -angle));
            updateVertices('back', backVerts);
            
            // èµ¤ã‚’é’ã®ä¸Šã«é…ç½®
            const frontVerts = closedCube.front.map(v => rotX(v, [-1, 0, -1], -angle));
            updateVertices('front', frontVerts);
            
            // ç™½ã‚’ç´«ã®ä¸‹ã«é…ç½®
            const topStep1 = closedCube.top.map(v => rotZ(v, [1, 0, -1], -angle));
            const topVerts = topStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
            updateVertices('top', topVerts);
        }
        
        // 1-3-2å‹ã®å±•é–‹é–¢æ•°
        function unfold1_3_2_G(t) {
            // G. 1-3-2å‹G (ã‚¸ã‚°ã‚¶ã‚°å‹) èµ¤(é»„ä¸Š) - é»„/é’/ç´« - ç™½ãƒ»ç·‘(ç´«ä¸‹ãŒç™½)
            const angle = t * 90;
            updateVertices('bottom', closedCube.bottom);
            
            const leftVerts = closedCube.left.map(v => rotZ(v, [-1, 0, -1], angle));
            updateVertices('left', leftVerts);
            
            const rightVerts = closedCube.right.map(v => rotZ(v, [1, 0, -1], -angle));
            updateVertices('right', rightVerts);
            
            // èµ¤ã‚’é»„ã®ä¸Šã«é…ç½®
            const frontStep1 = closedCube.front.map(v => rotZ(v, [-1, 0, -1], angle));
            const frontVerts = frontStep1.map(v => rotateAroundEdge(v, leftVerts[2], leftVerts[3], angle));
            updateVertices('front', frontVerts);
            
            // ç™½ã‚’ç´«ã®ä¸‹ã«é…ç½®
            const topStep1 = closedCube.top.map(v => rotZ(v, [1, 0, -1], -angle));
            const topVerts = topStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
            updateVertices('top', topVerts);
            
            // ç·‘ã‚’ç™½ã®å³ã«å±•é–‹ï¼šç´«ã¨åŒã˜å›è»¢â†’ç´«ã®ä¸‹è¾ºâ†’ç™½ã®å³è¾º
            const backStep1 = closedCube.back.map(v => rotZ(v, [1, 0, -1], -angle));
            const backStep2 = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
            const backVerts = backStep2.map(v => rotateAroundEdge(v, topVerts[1], topVerts[2], -angle));
            updateVertices('back', backVerts);
        }
        
        function unfold1_3_2_H(t) {
            // H. 1-3-2å‹H (Wå­—å‹) èµ¤(é’ä¸Š) - é»„/é’/ç´« - ç™½ãƒ»ç·‘(ç´«ä¸‹ãŒç™½)
            const angle = t * 90;
            updateVertices('bottom', closedCube.bottom);
            
            const leftVerts = closedCube.left.map(v => rotZ(v, [-1, 0, -1], angle));
            updateVertices('left', leftVerts);
            
            const rightVerts = closedCube.right.map(v => rotZ(v, [1, 0, -1], -angle));
            updateVertices('right', rightVerts);
            
            // èµ¤ã‚’é’ã®ä¸Šã«é…ç½®
            const frontVerts = closedCube.front.map(v => rotX(v, [-1, 0, -1], -angle));
            updateVertices('front', frontVerts);
            
            // ç™½ã‚’ç´«ã®ä¸‹ã«é…ç½®
            const topStep1 = closedCube.top.map(v => rotZ(v, [1, 0, -1], -angle));
            const topVerts = topStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
            updateVertices('top', topVerts);
            
            // ç·‘ã‚’ç™½ã®å³ã«å±•é–‹
            const backStep1 = closedCube.back.map(v => rotZ(v, [1, 0, -1], -angle));
            const backStep2 = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
            const backVerts = backStep2.map(v => rotateAroundEdge(v, topVerts[1], topVerts[2], -angle));
            updateVertices('back', backVerts);
        }
        
        function unfold1_3_2_I(t) {
            // I. 1-3-2å‹I (éšæ®µå‹) èµ¤(ç´«ä¸Š) - é»„/é’/ç´« - ç™½ãƒ»ç·‘(ç´«ä¸‹ãŒç™½)
            const angle = t * 90;
            updateVertices('bottom', closedCube.bottom);
            
            const leftVerts = closedCube.left.map(v => rotZ(v, [-1, 0, -1], angle));
            updateVertices('left', leftVerts);
            
            const rightVerts = closedCube.right.map(v => rotZ(v, [1, 0, -1], -angle));
            updateVertices('right', rightVerts);
            
            // èµ¤ã‚’ç´«ã®ä¸Šã«é…ç½®
            const frontStep1 = closedCube.front.map(v => rotZ(v, [1, 0, -1], -angle));
            const frontVerts = frontStep1.map(v => rotateAroundEdge(v, rightVerts[2], rightVerts[3], angle));
            updateVertices('front', frontVerts);
            
            // ç™½ã‚’ç´«ã®ä¸‹ã«é…ç½®
            const topStep1 = closedCube.top.map(v => rotZ(v, [1, 0, -1], -angle));
            const topVerts = topStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
            updateVertices('top', topVerts);
            
            // ç·‘ã‚’ç™½ã®å³ã«å±•é–‹
            const backStep1 = closedCube.back.map(v => rotZ(v, [1, 0, -1], -angle));
            const backStep2 = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
            const backVerts = backStep2.map(v => rotateAroundEdge(v, topVerts[1], topVerts[2], -angle));
            updateVertices('back', backVerts);
        }
        
        function unfold3_3_J(t) {
            // J. 3-3å‹J (ãƒ—ãƒ­ãƒšãƒ©å‹) ç·‘/ç´«/é’(ä¸Šæ®µ) - èµ¤/é»„/ç™½(ä¸‹æ®µã€ä¸Šæ®µå³ç«¯ã®ä¸‹ã‹ã‚‰)
            const angle = t * 90;
            
            // é’ã‚’å›ºå®šï¼ˆä¸Šæ®µå³ç«¯ï¼‰
            updateVertices('bottom', closedCube.bottom);
            
            // ç´«ã‚’é’ã®å·¦ã«é…ç½®ï¼ˆZè»¸å›è»¢ï¼‰
            const rightVerts = closedCube.right.map(v => rotZ(v, [1, 0, -1], angle));
            updateVertices('right', rightVerts);
            
            // ç·‘ã‚’ç´«ã®å·¦è¾ºã‚’è»¸ã«å›è»¢ã•ã›ã¦ã€ç´«ã®å·¦éš£ã«é…ç½®
            const backStep1 = closedCube.back.map(v => rotZ(v, [1, 0, -1], angle));
            const backVerts = backStep1.map(v => rotateAroundEdge(v, rightVerts[0], rightVerts[3], angle));
            updateVertices('back', backVerts);
            
            // èµ¤ã‚’é’ã®ä¸‹ã«é…ç½®ï¼ˆXè»¸å›è»¢ï¼‰
            const frontVerts = closedCube.front.map(v => rotX(v, [1, 0, -1], angle));
            updateVertices('front', frontVerts);
            
            // é»„ã‚’èµ¤ã®å³è¾ºã‚’è»¸ã«å›è»¢ã•ã›ã¦ã€èµ¤ã®å³éš£ã«é…ç½®
            const leftStep1 = closedCube.left.map(v => rotX(v, [1, 0, -1], angle));
            const leftVerts = leftStep1.map(v => rotateAroundEdge(v, frontVerts[1], frontVerts[2], angle));
            updateVertices('left', leftVerts);
            
            // ç™½ã‚’é»„ã®å³è¾ºã‚’è»¸ã«å›è»¢ã•ã›ã¦ã€é»„ã®å³éš£ã«é…ç½®
            const topStep1 = closedCube.top.map(v => rotX(v, [1, 0, -1], angle));
            const topStep2 = topStep1.map(v => rotateAroundEdge(v, frontVerts[1], frontVerts[2], angle));
            const topVerts = topStep2.map(v => rotateAroundEdge(v, leftVerts[1], leftVerts[2], angle));
            updateVertices('top', topVerts);
        }
        
        function unfold2_2_2_K(t) {
            // K. 2-2-2å‹K (éšæ®µå‹2) é»„/èµ¤ - é’/ç´« - ç™½/ç·‘
            const angle = t * 90;
            
            // é’ã‚’å›ºå®š
            updateVertices('bottom', closedCube.bottom);
            
            // èµ¤ã‚’é’ã®ä¸Šã«é…ç½®
            const frontVerts = closedCube.front.map(v => rotX(v, [-1, 0, -1], -angle));
            updateVertices('front', frontVerts);
            
            // é»„ã‚’èµ¤ã®å·¦è¾ºã‚’è»¸ã«å›è»¢ã•ã›ã¦ã€èµ¤ã®å·¦éš£ã«é…ç½®
            const leftStep1 = closedCube.left.map(v => rotX(v, [-1, 0, -1], -angle));
            const leftVerts = leftStep1.map(v => rotateAroundEdge(v, frontVerts[0], frontVerts[3], -angle));
            updateVertices('left', leftVerts);
            
            // ç´«ã‚’é’ã®å³ã«é…ç½®
            const rightVerts = closedCube.right.map(v => rotZ(v, [1, 0, -1], -angle));
            updateVertices('right', rightVerts);
            
            // ç™½ã‚’ç´«ã®ä¸‹ã«é…ç½®
            const topStep1 = closedCube.top.map(v => rotZ(v, [1, 0, -1], -angle));
            const topVerts = topStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
            updateVertices('top', topVerts);
            
            // ç·‘ã‚’ç™½ã®å³ã«å±•é–‹
            const backStep1 = closedCube.back.map(v => rotZ(v, [1, 0, -1], -angle));
            const backStep2 = backStep1.map(v => rotateAroundEdge(v, rightVerts[1], rightVerts[0], -angle));
            const backVerts = backStep2.map(v => rotateAroundEdge(v, topVerts[1], topVerts[2], -angle));
            updateVertices('back', backVerts);
        }
        
        function setProgress(p) {
            currentProgress = p;
            const unfoldFunctions = [
                unfold1_4_1_A,   // 0. A. 1-4-1å‹A (åå­—å‹)
                unfold1_4_1_B,   // 1. B. 1-4-1å‹B (å¸¯å‹1)
                unfold1_4_1_C,   // 2. C. 1-4-1å‹C (Lå­—å‹)
                unfold1_4_1_D,   // 3. D. 1-4-1å‹D (Lå­—å¤‰å½¢1)
                unfold1_4_1_E,   // 4. E. 1-4-1å‹E (Tå­—å‹)
                unfold1_4_1_F,   // 5. F. 1-4-1å‹F (å¸¯å‹2)
                unfold1_3_2_G,   // 6. G. 1-3-2å‹G (ã‚¸ã‚°ã‚¶ã‚°å‹)
                unfold1_3_2_H,   // 7. H. 1-3-2å‹H (Wå­—å‹)
                unfold1_3_2_I,   // 8. I. 1-3-2å‹I (éšæ®µå‹)
                unfold3_3_J,     // 9. J. 3-3å‹J (ãƒ—ãƒ­ãƒšãƒ©å‹)
                unfold2_2_2_K    // 10. K. 2-2-2å‹K (éšæ®µå‹2)
            ];
            unfoldFunctions[currentPattern](p);
        }
        
        function animateTo(target) {
            const start = currentProgress;
            const startTime = Date.now();
            const anim = () => {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / 2000, 1);
                const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                const p = start + (target - start) * eased;
                setProgress(p);
                document.getElementById('progressSlider').value = Math.round(p * 100);
                document.getElementById('progressValue').textContent = Math.round(p * 100);
                if (t < 1) requestAnimationFrame(anim);
            };
            anim();
        }
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
        const patternNames = [
            'A. 1-4-1å‹A (åå­—å‹)', 'B. 1-4-1å‹B (å¸¯å‹1)', 'C. 1-4-1å‹C (Lå­—å‹)', 
            'D. 1-4-1å‹D (Lå­—å¤‰å½¢1)', 'E. 1-4-1å‹E (Tå­—å‹)', 'F. 1-4-1å‹F (å¸¯å‹2)',
            'G. 1-3-2å‹G (ã‚¸ã‚°ã‚¶ã‚°å‹)', 'H. 1-3-2å‹H (Wå­—å‹)', 'I. 1-3-2å‹I (éšæ®µå‹)',
            'J. 3-3å‹J (ãƒ—ãƒ­ãƒšãƒ©å‹)', 'K. 2-2-2å‹K (éšæ®µå‹2)'
        ];
        
        document.querySelectorAll('.pattern-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const id = parseInt(btn.dataset.pattern);
                currentPattern = id;
                document.getElementById('currentPattern').textContent = `ç¾åœ¨: ${patternNames[id]}`;
                setProgress(currentProgress);
            };
        });
        
        document.getElementById('unfoldBtn').onclick = () => animateTo(1);
        document.getElementById('foldBtn').onclick = () => animateTo(0);
        document.getElementById('resetBtn').onclick = () => {
            setProgress(0);
            document.getElementById('progressSlider').value = 0;
            document.getElementById('progressValue').textContent = '0';
        };
        document.getElementById('progressSlider').oninput = e => {
            setProgress(e.target.value / 100);
            document.getElementById('progressValue').textContent = e.target.value;
        };
        
        // ãƒã‚¦ã‚¹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        let drag = false, prev = {x: 0, y: 0}, rot = {x: 0.4, y: 0.6};
        renderer.domElement.onmousedown = e => { drag = true; prev = {x: e.clientX, y: e.clientY}; };
        renderer.domElement.onmousemove = e => {
            if (drag) {
                rot.y += (e.clientX - prev.x) * 0.005;
                rot.x += (e.clientY - prev.y) * 0.005;
                prev = {x: e.clientX, y: e.clientY};
            }
        };
        renderer.domElement.onmouseup = () => drag = false;
        renderer.domElement.onwheel = e => {
            e.preventDefault();
            camera.position.z = Math.max(4, Math.min(20, camera.position.z + e.deltaY * 0.01));
        };
        
        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
        
        function animate() {
            requestAnimationFrame(animate);
            const r = camera.position.length();
            camera.position.set(
                r * Math.sin(rot.y) * Math.cos(rot.x),
                r * Math.sin(rot.x),
                r * Math.cos(rot.y) * Math.cos(rot.x)
            );
            camera.lookAt(0, 1, 0);
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
